<?xml version="1.0" encoding="UTF-8"?><feed xml:lang="en" xmlns="http://www.w3.org/2005/Atom"><id>https://www.paren.com/posts.atom</id><title type="text">(blog)</title><updated>2017-05-17T00:00:00.000Z</updated><link rel="self" href="https://www.paren.com/posts.atom"></link><entry><id>https://www.paren.com/posts/</id><title>ReactNative FAQ (for Web Developers)</title><author><name>Lily M. Goh</name></author><published>2017-05-17T00:00:00.000Z</published><updated>2017-05-17T00:00:00.000Z</updated><link href="https://www.paren.com/posts/" rel="alternate" type="text/html"></link><content type="html">&lt;p&gt;Recently, Paren took on its first mobile project using ReactNative. As a web developer, I’m excited to move into the mobile world. However, this transition came with a lot of frustrations. In this article I share my thoughts on the current state on React Native and its ecosystem from my perspective as a web developer. What follows are the most common ReactNative questions asked of me by my web developer friends.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Is ReactNative stable and ready for real world use?&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Yes, ReactNative is ready for real-world use. There are a lot of &lt;a href="https://facebook.github.io/react-native/showcase.html"&gt;production apps written using ReactNative&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;But stability is subjective. Compared to React, ReactNative is still very new. Web development (with or without React) is also a lot more mature than mobile development. Therefore, ReactNative tooling is not nearly as stable as web development tooling. To put React and ReactNative maturity into perspective: React currently has over 66k stars on Github and fewer than 600 issues while ReactNative has fewer than 50k stars but over 1,200 issues. React is a lot more stable and has a more adoption.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;What sort of apps is ReactNative good for? &lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;If you want to build an app that doesn’t use a lot of mobile-specific or complex functionality, like tracking footsteps, ReactNative and community libraries should cover most if not all of your requirements.&lt;/p&gt;&lt;p&gt;However, if you want to build a more complex app and ReactNative doesn’t provide the APIs you need, you would have to write native bridges to expose the native functionality. You can also rely on open source projects to provide native bridges for you, but that is not guaranteed to provide a complete solution.&lt;/p&gt;&lt;p&gt;In this project, we are using &lt;a href="https://expo.io/"&gt;Expo&lt;/a&gt;. Expo is awesome; it helps us move fast (and not break things, hopefully). Here are some of the things Expo provides:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Additional APIs and components not provided by ReactNative&lt;/li&gt;
  &lt;li&gt;A GUI and CLI that eliminate the need for XCode and Android Studio&lt;/li&gt;
  &lt;li&gt;An iOS and Android app for running Expo apps&lt;/li&gt;
  &lt;li&gt;Hosted infrastructure for instant deployment&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;The biggest problem with Expo is that, to fully benefit from Expo’s features and infrastructure, you cannot use custom native code. Most good ReactNative open-source libraries are incompatible with Expo because they use native code. We discussed tradeoffs of using Expo in more details in &lt;a href="https://youtu.be/tHQAMrShHu8?t=20m18s"&gt;our talk&lt;/a&gt;. &lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Is ReactNative good for prototyping?&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;Yes, ReactNative is great for prototyping and with Expo it is even better. Expo makes ReactNative mobile development more like web development. When you make JavaScript-only changes, you can push directly via Expo, instead of going through Apple’s or Google’s approval process. Expo uses &lt;a href="https://ngrok.com/"&gt;Ngrok&lt;/a&gt; during development, allowing you to open and hot-reload builds on any device, just like you would with a website and any browser.&lt;/p&gt;&lt;p&gt;If you already know and use React, getting started should be pretty easy. Surprisingly, styling proved to be the most challenging aspect for me. I say “surprisingly” because I know CSS quite well. However, there is no CSS in ReactNative; everything is styled with JavaScript. Inline styles are the only way to style components. If you aren’t familiar with inline styles, I encourage you to &lt;a href="https://speakerdeck.com/vjeux/react-css-in-js"&gt;view these slides&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;Inline styles do not cascade. The cascading property of CSS allows one to easily set global styles. For example, in CSS you could do something like &lt;code&gt;* {font-face: helvetica}&lt;/code&gt; and that should cascade to all DOM elements. In ReactNative, you would have to create a text component with the font styling that you want, and reuse that throughout the app. This makes sharing generic components in ReactNative more challenging than in React.&lt;/p&gt;&lt;p&gt;On the bright side, with ReactNative, you don’t have to deal with CSS insanity or supporting old browsers.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;How much Objective C or Java do I need to know?&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;As long as you are willing stay within the bounds of the ReactNative community, none. That’s one of the points of ReactNative. You only need to know how to write JavaScript with ReactNative. Although, a little bit of background in iOS and Android ecosystem would certainly help. If you decide not to use Expo you may occasionally need to do some configuration with Xcode or Android Studio.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;How much code can I realistically expect to share between iOS and Android?&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;There are significant differences between iOS and Android which &lt;a href="https://youtu.be/tHQAMrShHu8?t=18m33s"&gt;we talked about at Clojure/west&lt;/a&gt;. Each came with its own default styling, APIs, and UI components. Some behave similarly on both, some don’t. If you are building a generic app that doesn’t require a lot of native functionality, then almost all of the code can be shared.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;How should I structure the code base to support iOS and Android builds?&lt;/p&gt;
&lt;/blockquote&gt;&lt;p&gt;If you plan to use Expo like we do, you won’t have to worry about this. Without Expo, you will need to have two entry points; one for iOS and one for Android. You can start a basic Expo app by using &lt;a href="https://facebook.github.io/react-native/blog/2017/03/13/introducing-create-react-native-app.html"&gt;&lt;code&gt;create-react-native-app&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;Conclusion&lt;/h3&gt;&lt;p&gt;If you already know React and choose to use Expo, it should be pretty easy to get started. ReactNative is far from perfect but it’s good and getting better quickly. Giving it current stage and its cross-platform strength, it is hard to beat. For web developers who are already familiar with React, the pros definitely outweigh the cons.&lt;/p&gt;</content></entry><entry><id>https://www.paren.com/posts/</id><title>Isomorphic Clojure[Script]: Part 2 (Portable Code)</title><author><name>Dom Kiva-Meyer</name></author><published>2015-02-20T00:00:00.000Z</published><updated>2015-02-20T00:00:00.000Z</updated><link href="https://www.paren.com/posts/" rel="alternate" type="text/html"></link><content type="html">&lt;p&gt;The most fundamental abstraction necessary for building isomorphic applications is code portability. We need to be able to write once and run in the server &lt;em&gt;and&lt;/em&gt; browser. In a perfect world, we would write a language with identical syntax, semantics, and platform features. But that&amp;rsquo;s unrealistic, so let&amp;rsquo;s aim for similar syntax and semantics as well as an easy way to specify platform-specific units of code.&lt;/p&gt;&lt;p&gt;Our goal is for isomorphic Clojure[Script] applications to be more performant and easier to develop than their JavaScript counterparts. Outperforming JavaScript applications is easy; even V8 can&amp;rsquo;t touch the JVM when it comes to runtime performance and React with persistent data structures blows everything else away. But making isomorphic Clojure[Script] applications easier to develop than JavaScript ones is no small task.&lt;/p&gt;&lt;p&gt;While JavaScript on the server and in the browser are not identical in features, they are identical in syntax and semantics when they share features, which is not something that can be said of Clojure and ClojureScript. One option would be to throw Clojure out and only use ClojureScript by running it in Node on the backend. This is a completely valid option, but sacrifices JVM performance and the plethora of excellent Clojure and Java libraries that are available.&lt;/p&gt;&lt;p&gt;Let&amp;rsquo;s define the terms: An isomorphic Clojure[Script] application has a Clojure (JVM) backend and a ClojureScript (JavaScript) frontend where both sides of the application are capable of user-visible functionality like routing and rendering. This is the definition that I had in mind when writing &lt;a href="https://github.com/DomKM/omelette"&gt;Omelette&lt;/a&gt;. This architecture comes with more challenges than that of isomorphic JavaScript or isomorphic ClojureScript but the potential benefits make it worth pursuing. This post will focus on that of code portability. We want to write code that is portable; it will run in Clojure and ClojureScript and produce identical (or, in some cases, similar) results.&lt;/p&gt;&lt;h2&gt;Sharing Portable Code&lt;/h2&gt;&lt;p&gt;We need a way to share portable code so that we only have to write it once.&lt;/p&gt;&lt;h3&gt;Just Copy It&lt;/h3&gt;&lt;p&gt;The most obvious approach is to maintain multiple files per namespace; one file for each platform. Just copy the code from &amp;ldquo;namespace.clj&amp;rdquo; to &amp;ldquo;namespace.cljs&amp;rdquo; and modify the platform-specific parts.&lt;/p&gt;&lt;p&gt;But that&amp;rsquo;s just&amp;hellip;gross! Let&amp;rsquo;s never speak of this again.&lt;/p&gt;&lt;h3&gt;Use &lt;a href="https://github.com/emezeske/lein-cljsbuild/blob/8397716620e1686c9b1da27a00d8cbd30732d9c6/README.md"&gt;lein-cljsbuild crossovers&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;This tool copies &amp;ldquo;.clj&amp;rdquo; files to &amp;ldquo;.cljs&amp;rdquo; files. It&amp;rsquo;s better than the prior approach which shall not be named. However, its macro sharing functionality is clumsy and it totally ignores platform differences. For example, crossovers won&amp;rsquo;t help unify &lt;code&gt;(Float/parseFloat &amp;quot;3.14&amp;quot;)&lt;/code&gt; in Clojure with &lt;code&gt;(js/parseFloat &amp;quot;3.14&amp;quot;)&lt;/code&gt; in ClojureScript.&lt;/p&gt;&lt;p&gt;Crossovers is now deprecated in favor of &lt;a href="https://github.com/lynaghk/cljx"&gt;cljx&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;cljx&lt;/h3&gt;&lt;p&gt;This is what is used in Omelette. Given &amp;ldquo;namespace.cljx&amp;rdquo;, cljx outputs &amp;ldquo;namespace.clj&amp;rdquo; and &amp;ldquo;namespace.cljs&amp;rdquo; files. Forms prepended with &lt;code&gt;#+clj&lt;/code&gt; and &lt;code&gt;#+cljs&lt;/code&gt; are only output to &amp;ldquo;.clj&amp;rdquo; and &amp;ldquo;.cljs&amp;rdquo; files respectively. As with lein-cljsbuild crossovers, cljx is a source-to-source compiler. Unlike lein-cljsbuild crossovers, cljx is more granular &amp;ndash; compiling by form instead of file. This is the best solution that is currently available.&lt;/p&gt;&lt;h3&gt;Reader Conditionals&lt;/h3&gt;&lt;p&gt;Reader conditionals are a proposed feature in Clojure 1.7. You can read more about the design decisions and discussion on &lt;a href="http://dev.clojure.org/display/design/Reader+Conditionals"&gt;dev.clojure.org&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The current proposal satisfies the use case for cljx but differs in syntax and functionality. Unlike cljx, reader conditionals do not output new files; they extend the reader, allowing it to selectively read forms based on the current platform&amp;rsquo;s features.&lt;/p&gt;&lt;p&gt;Reader conditionals introduce two new literal forms: &lt;code&gt;#?&lt;/code&gt; (&lt;code&gt;read-cond&lt;/code&gt;) and &lt;code&gt;#?@&lt;/code&gt; (&lt;code&gt;read-cond-splicing&lt;/code&gt;). The former reads a single expression and the latter reads a list and splices it into the parent form. Here&amp;rsquo;s an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="clojure"&gt;(ns my.namespace
  (:require [foo.bar #?@(:cljs [:include-macros true])]
            [#?(:clj clojure.core.async :cljs cljs.core.async) :as csp])
  #?(:cljs (:require-macros [cljs.core.async.macros :as csp])))
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Challenges&lt;/h2&gt;&lt;p&gt;The fact that we can target the JVM and JavaScript from a single codebase is remarkable but is not without its challenges.&lt;/p&gt;&lt;h3&gt;&lt;code&gt;(set/intersection Clojure ClojureScript)&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;ClojureScript is not a subset of Clojure. It contains functionality that Clojure lacks. Portable code must target the intersection of Clojure and ClojureScript. That means no &lt;code&gt;extend&lt;/code&gt; from Clojure or &lt;code&gt;specify&lt;/code&gt; (an incredibly useful but underutilized function) from ClojureScript.&lt;/p&gt;&lt;h3&gt;Macros&lt;/h3&gt;&lt;p&gt;ClojureScript lacks native macros but is able to make use of Clojure macros. This is undoubtedly useful but is also lacking in several ways.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Since ClojureScript lacks macros but can use Clojure macros, any platform-specific macro functionality will need to be implemented using conditionals and the contents of &lt;code&gt;&amp;amp;env&lt;/code&gt;. (Within a macro, &lt;code&gt;(:ns &amp;amp;env)&lt;/code&gt; is only truthy when expanding ClojureScript code.)&lt;/li&gt;
  &lt;li&gt;Macros are Clojure&amp;rsquo;s only facility for doing work before runtime and are incredibly useful for optimizing performance without sacrificing syntax. The ability to do this in ClojureScript is significantly diminished because macros in ClojureScript (which are Clojure macros) cannot call ClojureScript functions.&lt;/li&gt;
  &lt;li&gt;Since ClojureScript macros are really Clojure macros, symbols are resolved in Clojure. For example, &lt;code&gt;map&lt;/code&gt; would resolve to &lt;code&gt;clojure.core/map&lt;/code&gt; instead of &lt;code&gt;cljs.core/map&lt;/code&gt;. The only way around this faulty resolution is to quote and then unquote the symbol, like &lt;code&gt;~&amp;#39;map&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Core Implementation&lt;/h3&gt;&lt;p&gt;Clojure is primarily implemented with Java classes and interfaces in &lt;code&gt;clojure.lang.*&lt;/code&gt;. ClojureScript is primarily implemented with types and protocols in &lt;code&gt;cljs.core/*&lt;/code&gt;. This makes it cumbersome to extend core functionality.&lt;/p&gt;&lt;p&gt;For example, let&amp;rsquo;s say we have a protocol that we want to extend to maps:&lt;/p&gt;
&lt;pre&gt;&lt;code class="clojure"&gt;(defprotocol KeywordKeys
  (keyword-keys [this] &amp;quot;Returns a seq of keys that are also keywords.&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In Clojure, we can extend it to the &lt;code&gt;IPersistentMap&lt;/code&gt; interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class="clojure"&gt;(extend-protocol KeywordKeys
  clojure.lang.IPersistentMap
  (keyword-keys [this] (filter keyword? (keys this))))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In ClojureScript, we can only extend to concrete types because ClojureScript lacks interfaces and protocols cannot be extended to other protocols:&lt;/p&gt;
&lt;pre&gt;&lt;code class="clojure"&gt;(extend-protocol KeywordKeys
  PersistentArrayMap
  (keyword-keys [this] (filter keyword? (keys this)))
  PersistentHashMap
  (keyword-keys [this] (filter keyword? (keys this))))
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Namespaces&lt;/h3&gt;&lt;p&gt;ClojureScript namespace declarations significantly differ from Clojure namespace declarations.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ClojureScript has all sorts of extras for dealing with macros like &lt;code&gt;:require-macros&lt;/code&gt; and &lt;code&gt;:include-macros&lt;/code&gt;. The Clojure &lt;code&gt;ns&lt;/code&gt; macro does not know how to deal with these extensions.&lt;/li&gt;
  &lt;li&gt;ClojureScript intentionally lacks &lt;code&gt;:use&lt;/code&gt; and &lt;code&gt;:refer :all&lt;/code&gt;. The ClojureScript &lt;code&gt;ns&lt;/code&gt; macro does not know how to deal with these features.&lt;/li&gt;
  &lt;li&gt;Due to implementation differences, Clojure types are brought into a namespace with &lt;code&gt;:import&lt;/code&gt; but ClojureScript types are brought into a namespace with &lt;code&gt;:require&lt;/code&gt; and &lt;code&gt;:refer&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;ClojureScript namespaces are inconsistently named (&lt;code&gt;cljs.core&lt;/code&gt; vs. &lt;code&gt;clojure.core&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;ClojureScript lacks some of Clojure&amp;rsquo;s namespaces like &lt;code&gt;clojure.edn&lt;/code&gt; and Clojure lacks some of ClojureScript&amp;rsquo;s namespaces like &lt;code&gt;cljs.reader&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Unlike other parts of ClojureScript which can be made to be more similar to Clojure via macros, namespaces are completely closed to user extension because ClojureScript lacks &lt;code&gt;require&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;All of these issues combine to make namespaces declarations the most clumsy and redundant part of portable code.&lt;/p&gt;&lt;h3&gt;Host Interop&lt;/h3&gt;&lt;p&gt;Clojure&amp;rsquo;s standard library lacks common functionality like &lt;code&gt;parseInt&lt;/code&gt;. This is fine when running &lt;em&gt;only&lt;/em&gt; on the JVM but causes pain when writing portable code due to Java and JavaScript inconsistencies. Since &lt;code&gt;java.lang.*&lt;/code&gt; is imported into &lt;code&gt;clojure.core&lt;/code&gt; but global JavaScript properties are accessible as &lt;code&gt;js/*&lt;/code&gt;, even interop where Java and JavaScript are consistent require Clojure and ClojureScript forms that are inconsistent.&lt;/p&gt;&lt;p&gt;Additionally, even though Java and JavaScript ostensibly share some core types, they are often referenced differently in ClojureScript than in Clojure. For example, you &lt;code&gt;extend-protocol&lt;/code&gt; to &lt;code&gt;String&lt;/code&gt; in Clojure but &lt;code&gt;string&lt;/code&gt; in ClojureScript. Similar pain occurs around exception handling and type hinting, since those parts of Clojure and ClojureScript are, at most, a paper-thin wrapper over their host platforms.&lt;/p&gt;&lt;h3&gt;Concurrency&lt;/h3&gt;&lt;p&gt;Clojure&amp;rsquo;s concurrency primitives were designed with the JVM in mind and therefore require blocking. Since JavaScript is non-blocking, ClojureScript lacks Clojure&amp;rsquo;s &lt;code&gt;future&lt;/code&gt;, &lt;code&gt;promise&lt;/code&gt;, &lt;code&gt;agent&lt;/code&gt;, and &lt;code&gt;ref&lt;/code&gt; concurrency primitives because they can block on &lt;code&gt;deref&lt;/code&gt;. Without using any external libraries, writing portable concurrent code is tough.&lt;/p&gt;&lt;h2&gt;Positives&lt;/h2&gt;&lt;h3&gt;&lt;code&gt;core.async&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;Move &amp;ldquo;Concurrency&amp;rdquo; over to the positives because &lt;code&gt;core.async&lt;/code&gt; rocks! It is tremendously helpful because it lets us write roughly the same asynchronous code in Clojure or ClojureScript despite ClojureScript neither having threads or being able to block. This is huge!&lt;/p&gt;&lt;p&gt;The community has been justifiable excited about &lt;code&gt;core.async&lt;/code&gt;. While it is great in Clojure or ClojureScript, it really shines when writing portable code.&lt;/p&gt;&lt;h3&gt;It works!&lt;/h3&gt;&lt;p&gt;I can still barely believe that I am able to write virtually the same syntax and utilize Clojure&amp;rsquo;s incredible features while enjoying JavaScript&amp;rsquo;s incredible reach. Run everywhere JavaScript runs but write Clojure instead of JavaScript? Yes, please!&lt;/p&gt;</content></entry><entry><id>https://www.paren.com/posts/</id><title>Isomorphic Clojure[Script]: Part 2 (Introduction)</title><author><name>Dom Kiva-Meyer</name></author><published>2015-02-19T00:00:00.000Z</published><updated>2015-02-19T00:00:00.000Z</updated><link href="https://www.paren.com/posts/" rel="alternate" type="text/html"></link><content type="html">&lt;p&gt;Part 2 is about problems with the abstractions in &lt;a href="https://github.com/DomKM/omelette"&gt;Omelette&lt;/a&gt; and, more optimistically, where we can go from here to improve the isomorphic Clojure[Script] story.&lt;/p&gt;&lt;p&gt;This post is split into multiple parts; one part per abstraction.&lt;/p&gt;&lt;h2&gt;Abstractions&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="/posts/isomorphic-clojure-part-2-portable-code"&gt;Portable Code&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Routing&lt;/li&gt;
  &lt;li&gt;Rendering&lt;/li&gt;
  &lt;li&gt;State Management &amp;amp; Synchronization&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><id>https://www.paren.com/posts/</id><title>Isomorphic Clojure[Script]: Part 1</title><author><name>Dom Kiva-Meyer</name></author><published>2014-06-15T00:00:00.000Z</published><updated>2015-01-01T00:00:00.000Z</updated><link href="https://www.paren.com/posts/" rel="alternate" type="text/html"></link><content type="html">&lt;p&gt;In pursuit of supporting a dynamic and interactive user experience, developers have been shifting from traditional server-rendered multi-page applications (MPAs) to browser-rendered single-page applications (SPAs).&lt;/p&gt;&lt;p&gt;An MPA is a website that serves fully-formed or mostly-formed HTML when a client requests a page. Links cause the browser to request a new page; blowing away the previous DOM, CSSOM, and JS context. If rendered without JS execution, MPAs remain viewable and at least partially usable.&lt;/p&gt;&lt;p&gt;An SPA is a website that serves mostly bare HTML. Upon initialization, the JS requests data for that page and updates the DOM. Clicking links trigger asynchronous requests for new data and then modify the DOM (and sometimes &lt;code&gt;window.history&lt;/code&gt; or &lt;code&gt;window.location&lt;/code&gt;). The same DOM, CSSOM, and JS contexts live through the entire client session.&lt;/p&gt;&lt;p&gt;The web has matured and become a fairly capable application platform and SPAs utilize this platform to provide better experiences to users and developers. For users, applications can be more responsive to interaction and better facilitate dynamic experiences that are not possible/feasible with MPAs. For developers, building SPAs can provide a clearer separation of concerns and tends to enforce more browser-side code structure. However, embracing SPAs is not without its drawbacks.&lt;/p&gt;&lt;h3&gt;MPA Pros &amp;amp; SPA Cons&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SEO&lt;/strong&gt;&lt;br/&gt; Until &lt;a href="http://googlewebmastercentral.blogspot.com/2014/05/understanding-web-pages-better.html"&gt;recently&lt;/a&gt;, no major search engine executed JS. Though the only search engine that you care about reports to now execute JS, I would not be the first to question if this will put SPAs on equal footing with MPAs. Even if Google treats them the same, SPAs have significantly slower initial page-load speed and that negatively affects SEO. To serve fully-formed HTML, developers have resorted to crazy workarounds like rendering SPAs in headless browsers and serving HTML extracted from there. Needless to say, this introduces a whole new level of complexity.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Page-Load Performance&lt;/strong&gt;&lt;br/&gt; Serving fully-formed HTML is &lt;em&gt;fast&lt;/em&gt;. Speed matters. Metrics from large companies have repeatedly demonstrated that user engagement decreases as latency increases. Rendering an initial page for an MPA requires fewer requests than for an SPA. For initial renders, SPAs additionally need to request and receive JS, execute it, and then request and receive data for that page.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Connection Quality&lt;/strong&gt;&lt;br/&gt; Slow or inconsistent connections can make SPAs unusable. This is particularly important for mobile users.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Accessibility&lt;/strong&gt;&lt;br/&gt; Most screen readers and &amp;ldquo;read it later&amp;rdquo; applications don&amp;rsquo;t execute JS. The award for worst use of an SPA has to go to Google&amp;rsquo;s Blogger; an application ostensibly meant to serve mostly static documents that is now slower than when it was an MPA and unusable without JS.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Graceful Degradation&lt;/strong&gt;&lt;br/&gt; MPAs tend to degrade more gracefully than SPAs. You&amp;rsquo;re stuck with a blank page if JS fails to load on an SPA page, but you can probably still view the page and click links if it fails to load on an MPA page.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Maintainability&lt;/strong&gt;&lt;br/&gt; Validation, routing, and other logic often need to be shared by the browser-side and server-side code. However, the codebases are typically written in different languages, so logic needs to be duplicated and then kept in sync.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;(Multi|Single)-Page Applications&lt;/h3&gt;&lt;p&gt;We want a hybrid approach that blends the benefits of MPAs and SPAs. We want to serve fully-formed HTML for initial requests and, after the page loads, we want the browser-side application to take over and become an SPA. We want to avoid the above issues and enjoy all of the benefits of SPAs without paying the costs traditionally incurred by them.&lt;/p&gt;&lt;p&gt;Isomorphic is a term used to describe applications where the frontend and backend code are written in the same language and share a significant amount of logic, which facilitates features like this. Isomorphism has primarily been achieved by using JS (or a language like CoffeeScript that is little more than syntactic sugar for JS) on the server. In fact, I&amp;rsquo;ve only seen the term &amp;ldquo;Isomorphic&amp;rdquo; used when immediately preceding &amp;ldquo;JavaScript,&amp;rdquo; but that doesn&amp;rsquo;t have to be the case.&lt;/p&gt;&lt;h3&gt;A Better Language&lt;/h3&gt;&lt;p&gt;ClojureScript tools have changed dramatically in the past year.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://github.com/facebook/react"&gt;React&lt;/a&gt;, an excellent JS library for rendering, was released in May 2013. React supports multiple render targets; it can render to a DOM element or to an HTML string.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/swannodette/om"&gt;Om&lt;/a&gt;, a ClojureScript wrapper for React that provides some important performance and architectural advantages, was released in January 2014.&lt;/li&gt;
  &lt;li&gt;JDK 8, which ships with a high-performance JavaScript engine called Nashorn that is compatible with React, was released in March 2014.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/clojure/core.async/"&gt;core.async&lt;/a&gt;, a Clojure[Script] library that provides a great concurrency model, was released in June 2013.&lt;/li&gt;
  &lt;li&gt;&lt;a href="https://github.com/ptaoussanis/sente/"&gt;Sente&lt;/a&gt;, a Clojure[Script] library for bidirectional asynchronous communication over HTTP and Web Sockets via core.async&amp;rsquo;s channel interface, was released in February 2014.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Though the toolset is not yet complete (which I will discuss further in Part 2), these libraries go a long way toward enabling isomorphism where it was previously infeasible.&lt;/p&gt;&lt;p&gt;Instead of running JS across the entire stack, we could run server-side Clojure, browser-side ClojureScript, render fully-formed HTML using Nashorn with Om/React, and share client and server code since Clojure and ClojureScript have nearly identical syntax and semantics.&lt;/p&gt;&lt;h3&gt;Is Clojure[Script] Ready?&lt;/h3&gt;&lt;p&gt;I wrote &lt;a href="https://github.com/DomKM/omelette"&gt;Omelette&lt;/a&gt;, an example application, to experiment with isomorphic Clojure[Script] patterns. It&amp;rsquo;s a basic word-finding application. Given a string and desired position/s, it returns a list of words where the string is in the desired position. For example, searching for words that start with &amp;ldquo;om&amp;rdquo; would return a list that includes &amp;ldquo;omelette.&amp;rdquo;&lt;/p&gt;&lt;p&gt;The goal was to make an isomorphic SPA where all routes are renderable by the server without a significant amount of extra work, code duplication, or &lt;code&gt;(if server? ...)&lt;/code&gt; conditionals. Additionally, the client-side code should be able to take over transparently and quickly; no white flash and no additional requests.&lt;/p&gt;&lt;h3&gt;Abstractions&lt;/h3&gt;&lt;p&gt;The code needed to work in three dissimilar environments: Clojure in the JVM, ClojureScript in Nashorn in the JVM, and ClojureScript in the browser. Sharing code requires abstractions.&lt;/p&gt;&lt;h4&gt;State Management&lt;/h4&gt;&lt;p&gt;The state of the application needs to be able to be usable in every environment. This one is easy since Clojure and ClojureScript have nearly identical syntax and semantics and can serialize to and deserialize from &lt;a href="https://github.com/edn-format/edn"&gt;EDN&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Omelette stores application state as a 2-tuple where the elements are a namespaced page keyword and a map of page data. For example, an application state of &lt;code&gt;[:omelette.page/search {:query &amp;quot;bloop&amp;quot; :options #{:prefix}}]&lt;/code&gt; represents the &amp;ldquo;Search&amp;rdquo; page with a query input value of &lt;code&gt;&amp;quot;bloop&amp;quot;&lt;/code&gt; and the &lt;code&gt;:prefix&lt;/code&gt; option checked, while &lt;code&gt;[:omelette.page/about {:markdown &amp;quot;# About ...&amp;quot;}]&lt;/code&gt; represents the &amp;ldquo;About&amp;rdquo; page with Markdown content.&lt;/p&gt;&lt;h4&gt;Rendering&lt;/h4&gt;&lt;p&gt;The application needs to be able to render to a DOM element and to an HTML string on the client-side and server-side respectively. Also, the browser-side application needs to be able to transition from static, server-rendered HTML to dynamic DOM rendering when it initializes in a browser.&lt;/p&gt;&lt;p&gt;Omelette uses Om/React for rendering. To serve HTML, Omelette server-side code uses an application state 2-tuple to render the view to a string within Nashorn, which returns a normal instance of &lt;code&gt;java.lang.String&lt;/code&gt;. The HTML is embedded in a &lt;code&gt;div&lt;/code&gt; in the document layout. The state is also serialized as EDN and embedded in the layout so that, when Omelette initializes in a browser, it doesn&amp;rsquo;t have to make an additional request to fetch the initial data.&lt;/p&gt;&lt;h4&gt;Data Retrieval and Persistence&lt;/h4&gt;&lt;p&gt;Retrieving and persisting data needs to be easy to do for both initial page requests and running browser-side applications.&lt;/p&gt;&lt;p&gt;Omelette uses Sente for communication and reuses Sente&amp;rsquo;s handler function for server-side rendering. Using the same handler makes it very easy to share this functionality.&lt;/p&gt;&lt;h4&gt;Routing&lt;/h4&gt;&lt;p&gt;Routing needs to work without requiring access to environment-specific things like the browser&amp;rsquo;s &lt;code&gt;window&lt;/code&gt; object or the server&amp;rsquo;s incoming HTTP request. However, routes should be &lt;em&gt;able&lt;/em&gt; to make use of environment-specific things, particularly on the server for authentication and authorization.&lt;/p&gt;&lt;p&gt;Omelette&amp;rsquo;s search page is rendered at &lt;code&gt;&amp;quot;/&amp;quot;&lt;/code&gt;, &lt;code&gt;&amp;quot;/search&amp;quot;&lt;/code&gt;, and &lt;code&gt;&amp;quot;/search/:options/:query&amp;quot;&lt;/code&gt; where &lt;code&gt;:options&lt;/code&gt; is the desired position/s and &lt;code&gt;:query&lt;/code&gt; is the target string. For example, &lt;code&gt;&amp;quot;/search/prefix/bloop&amp;quot;&lt;/code&gt; is the path to find words that start with &lt;code&gt;&amp;quot;bloop&amp;quot;&lt;/code&gt;. The &amp;ldquo;About&amp;rdquo; page is rendered at &lt;code&gt;&amp;quot;/about&amp;quot;&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;Routing in Omelette is unlike any routing functionality that I have seen elsewhere, so we should probably discuss it here. It has two steps:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;A path (&lt;code&gt;&amp;quot;/search/bloop/prefix&amp;quot;&lt;/code&gt;) is transformed into an application state 2-tuple (&lt;code&gt;[:omelette.page/search {:query &amp;quot;bloop&amp;quot; :options #{:prefix}}]&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;An application state 2-tuple (&lt;code&gt;[:omelette.page/search {:query &amp;quot;bloop&amp;quot; :options #{:prefix}}]&lt;/code&gt;) is passed through a handler function that pattern matches the state using &lt;a href="https://github.com/clojure/core.match"&gt;core.match&lt;/a&gt; and returns or responds with a modified state (&lt;code&gt;[:omelette.page/search {:query &amp;quot;bloop&amp;quot; :options #{:prefix} :results (&amp;quot;bloop&amp;quot; &amp;quot;blooper&amp;quot; &amp;quot;blooping&amp;quot;)}]&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;All routes and application states are bidirectional. For example, the path &lt;code&gt;&amp;quot;/search/bloop/prefix&amp;quot;&lt;/code&gt; can be derived from the application state returned from either of the above steps.&lt;/p&gt;&lt;p&gt;Additionally, though this is not strictly routing, document titles can be derived from application states. This is used for setting and updating the document title on the server and browser respectively.&lt;/p&gt;&lt;p&gt;Routing in Omelette is entirely ad hoc. In other words, routes are not defined using any sort of abstraction, but are manually converted to and from application state 2-tuples.&lt;/p&gt;&lt;p&gt;Routing is not a solved problem. There are no major Clojure[Script] routing libraries.&lt;/p&gt;&lt;h3&gt;Step by Step&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;A request is made to &lt;code&gt;&amp;quot;/search/prefix/bloop&amp;quot;&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The request is converted to application state 2-tuple: &lt;code&gt;[:omelette.page/search {:query &amp;quot;bloop&amp;quot; :options #{:prefix}}]&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The state gets passed through a handler function that returns a complete state: &lt;code&gt;[:omelette.page/search {:query &amp;quot;bloop&amp;quot; :options #{:prefix} :results (&amp;quot;bloop&amp;quot; &amp;quot;blooper&amp;quot; &amp;quot;blooping&amp;quot;)}]&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The complete state is serialized to EDN and passed to Om/React through Nashorn, which returns an HTML string for that state.&lt;/li&gt;
  &lt;li&gt;The Om/React HTML string and application state EDN are inserted into the &lt;code&gt;body&lt;/code&gt; of an HTML layout to form a complete document.&lt;/li&gt;
  &lt;li&gt;A response is sent with the document and a status that is determined by the page keyword; 404 if &lt;code&gt;:omelette.page/not-found&lt;/code&gt;, 200 otherwise.&lt;/li&gt;
  &lt;li&gt;The Om/React application loads, uses the embedded EDN as the initial application state, and then mounts into the embedded HTML.&lt;/li&gt;
  &lt;li&gt;The ClojureScript router listens for navigation events and application state changes.&lt;/li&gt;
  &lt;li&gt;When the ClojureScript router detects a change, it updates &lt;code&gt;window.history&lt;/code&gt; and sends the new application state (either the authoritative state or a state derived from the navigation event) to the server via Sente.&lt;/li&gt;
  &lt;li&gt;Sente passes the new state to the Clojure handler function. Since this time it is not an initial request, the router responds via Sente with an updated state.&lt;/li&gt;
  &lt;li&gt;Sente passes the new new state to the ClojureScript handler function which then updates the application state.&lt;/li&gt;
  &lt;li&gt;GOTO 9&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;Wrapping Up&lt;/h3&gt;&lt;p&gt;The full code for Omelette: &lt;a href="https://github.com/DomKM/omelette"&gt;github.com/DomKM/omelette&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Take a look at &lt;a href="https://github.com/DomKM/omelette/blob/master/src%2Fomelette%2Frender.clj"&gt;&lt;code&gt;omelette.render&lt;/code&gt; to see how Nashorn is used&lt;/a&gt; and &lt;a href="https://github.com/DomKM/omelette/blob/master/src%2Fomelette%2Fview.cljs"&gt;&lt;code&gt;omelette.view&lt;/code&gt; to read through the Om code for rendering&lt;/a&gt;. The bulk of Omelette&amp;rsquo;s code is in &lt;a href="https://github.com/DomKM/omelette/blob/master/src%2Fomelette%2Froute.cljx"&gt;&lt;code&gt;omelette.route&lt;/code&gt;&lt;/a&gt; This uses &lt;a href="https://github.com/lynaghk/cljx"&gt;cljx&lt;/a&gt;, a tool that compiles .cljx files to both .clj and .cljs files. Forms prepended with &lt;code&gt;#+clj&lt;/code&gt; and &lt;code&gt;#+cljs&lt;/code&gt; will only be output to .clj and .cljs files respectively. This makes it easy to target both Clojure and ClojureScript with the same codebase. &lt;code&gt;omelette.route&lt;/code&gt; provides routing helper functions, a ClojureScript router component using Om, and a Clojure router component using the descriptively but generically named &lt;a href="https://github.com/stuartsierra/component"&gt;Component&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Part 2 will discuss problems with the above approach to isomorphic Clojure[Script] and new libraries/patterns to alleviate these problems. Spoiler: It will be feasible to do server-side rendering without using Nashorn or any JS engine in the not-too-distant future.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Thanks to &lt;a href="http://nelsonmorris.net/"&gt;Nelson Morris&lt;/a&gt; and &lt;a href="http://aphyr.com/"&gt;Kyle Kingsbury&lt;/a&gt; for reviewing drafts of Omelette.&lt;/em&gt;&lt;/p&gt;</content></entry></feed>