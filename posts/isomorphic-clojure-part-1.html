<!DOCTYPE html><html lang="en">
<!-- Mirrored from localhost:8080/posts/isomorphic-clojure-part-1 by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2023 22:58:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8" /><script src="../cdn-cgi/apps/head/8eW9U_40SfsrDtemBGnQeBr-CA0.js"></script><link href="http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Open+Sans:300,300italic,400,400italic,700,700italic" rel="stylesheet" type="text/css" /><link href="../bundles/25f08f0a7b5e/main.css" rel="stylesheet" type="text/css" /><title>Isomorphic Clojure[Script]: Part 1 | (paren)</title><meta content="An experiment in applying isomorphic concepts to Clojure[Script] applications." name="description" /><link href="https://www.paren.com/posts/isomorphic-clojure-part-1" rel="canonical" /><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="../assets/images/c369d834ca33/favicon-180.png" rel="apple-touch-icon" /><meta content="#FFFFFF" name="msapplication-TileColor" /><meta content="/assets/images/c369d834ca33/favicon-180.png" name="msapplication-TileImage" /><meta content="Isomorphic Clojure[Script]: Part 1" property="og:title" /><meta content="https://www.paren.com/posts/isomorphic-clojure-part-1" property="og:url" /><meta content="An experiment in applying isomorphic concepts to Clojure[Script] applications." property="description" /><meta content="en_US" property="og:locale" /><meta content="(paren)" property="og:site_name" /><meta content="article" property="og:type" /><meta content="2014-06-15T00:00:00.000Z" property="article:published_time" /><meta content="2015-01-01T00:00:00.000Z" property="article:modified_time" /><meta content="https://www.facebook.com/DomKM" property="article:author" /><meta content="isomorphic" property="article:tag" /><meta content="clojure" property="article:tag" /><meta content="sente" property="article:tag" /><meta content="om" property="article:tag" /><meta content="nashorn" property="article:tag" /><meta content="react" property="article:tag" /><meta content="clojurescript" property="article:tag" /><meta content="summary" name="twitter:card" /><meta content="@paren_com" name="twitter:site" /><meta content="Isomorphic Clojure[Script]: Part 1" name="twitter:title" /><meta content="An experiment in applying isomorphic concepts to Clojure[Script] applications." name="twitter:description" /><meta content="@DomKM" name="twitter:creator" /><link href="../sitemap.xml" rel="sitemap" title="Sitemap" type="application/xml" /><link href="../posts.atom" title="(blog)" type="application/atom+xml" /></head><body><header class="navigation"><div class="navigation-wrapper"><a class="logo" href="../index.html" style="margin-top:5px;margin-left:5px;"><img height="35" src="../assets/images/ca89ec253a40/paren-logo.png" width="126" /></a><label class="icon ion-navicon" id="hamburger-button"></label><ul class="navigation-menu"><a href="../index.html#testimonials">testimonials</a><a href="../index.html#videos">videos</a><a href="../index.html#process">process</a><a href="../index.html#team">team</a><a href="../index.html#contact">contact</a><a href="../posts.html">blog</a></ul></div></header><div id="main"><article id="post"><h1>Isomorphic Clojure[Script]</h1><h2>Part 1</h2><div class="post-data"><span class="post-author"><a href="https://twitter.com/DomKM" target="_blank">Dom Kiva-Meyer</a></span><time class="published" datetime="2014-06-15T00:00:00.000Z">June 15, 2014</time></div><ul class="post-tags"><li><a href="../posts3c57.html?tag=clojure">clojure</a></li><li><a href="../postsc8a0.html?tag=clojurescript">clojurescript</a></li><li><a href="../posts0af7.html?tag=isomorphic">isomorphic</a></li><li><a href="../posts6875.html?tag=nashorn">nashorn</a></li><li><a href="../posts533c.html?tag=om">om</a></li><li><a href="../posts592a.html?tag=react">react</a></li><li><a href="../posts8c28.html?tag=sente">sente</a></li></ul><ul class="share-buttons"><li class="share-button"><a class="twitter-share-button" data-related="paren_com" data-text="Isomorphic Clojure[Script]: Part 1" data-url="https://www.paren.com/posts/isomorphic-clojure-part-1" data-via="paren_com"></a></li><li class="share-button"><a class="fb-share-button" data-href="https://www.paren.com/posts/isomorphic-clojure-part-1" data-layout="button_count"></a></li><li class="share-button"><a class="g-plusone" data-annotation="bubble" data-href="https://www.paren.com/posts/isomorphic-clojure-part-1" data-size="medium"></a></li><li class="share-button"><a><script data-counter="right" data-showzero="true" data-url="https://www.paren.com/posts/isomorphic-clojure-part-1" type="IN/Share"></script></a></li></ul><div class="post-body"><p>In pursuit of supporting a dynamic and interactive user experience, developers have been shifting from traditional server-rendered multi-page applications (MPAs) to browser-rendered single-page applications (SPAs).</p><p>An MPA is a website that serves fully-formed or mostly-formed HTML when a client requests a page. Links cause the browser to request a new page; blowing away the previous DOM, CSSOM, and JS context. If rendered without JS execution, MPAs remain viewable and at least partially usable.</p><p>An SPA is a website that serves mostly bare HTML. Upon initialization, the JS requests data for that page and updates the DOM. Clicking links trigger asynchronous requests for new data and then modify the DOM (and sometimes <code>window.history</code> or <code>window.location</code>). The same DOM, CSSOM, and JS contexts live through the entire client session.</p><p>The web has matured and become a fairly capable application platform and SPAs utilize this platform to provide better experiences to users and developers. For users, applications can be more responsive to interaction and better facilitate dynamic experiences that are not possible/feasible with MPAs. For developers, building SPAs can provide a clearer separation of concerns and tends to enforce more browser-side code structure. However, embracing SPAs is not without its drawbacks.</p><h3>MPA Pros &amp; SPA Cons</h3>
<ul>
<li><strong>SEO</strong><br /> Until <a href="https://googlewebmastercentral.blogspot.com/2014/05/understanding-web-pages-better.html">recently</a>, no major search engine executed JS. Though the only search engine that you care about reports to now execute JS, I would not be the first to question if this will put SPAs on equal footing with MPAs. Even if Google treats them the same, SPAs have significantly slower initial page-load speed and that negatively affects SEO. To serve fully-formed HTML, developers have resorted to crazy workarounds like rendering SPAs in headless browsers and serving HTML extracted from there. Needless to say, this introduces a whole new level of complexity.</li>
<li><strong>Page-Load Performance</strong><br /> Serving fully-formed HTML is <em>fast</em>. Speed matters. Metrics from large companies have repeatedly demonstrated that user engagement decreases as latency increases. Rendering an initial page for an MPA requires fewer requests than for an SPA. For initial renders, SPAs additionally need to request and receive JS, execute it, and then request and receive data for that page.</li>
<li><strong>Connection Quality</strong><br /> Slow or inconsistent connections can make SPAs unusable. This is particularly important for mobile users.</li>
<li><strong>Accessibility</strong><br /> Most screen readers and &ldquo;read it later&rdquo; applications don&rsquo;t execute JS. The award for worst use of an SPA has to go to Google&rsquo;s Blogger; an application ostensibly meant to serve mostly static documents that is now slower than when it was an MPA and unusable without JS.</li>
<li><strong>Graceful Degradation</strong><br /> MPAs tend to degrade more gracefully than SPAs. You&rsquo;re stuck with a blank page if JS fails to load on an SPA page, but you can probably still view the page and click links if it fails to load on an MPA page.</li>
<li><strong>Maintainability</strong><br /> Validation, routing, and other logic often need to be shared by the browser-side and server-side code. However, the codebases are typically written in different languages, so logic needs to be duplicated and then kept in sync.</li>
</ul><h3>(Multi|Single)-Page Applications</h3><p>We want a hybrid approach that blends the benefits of MPAs and SPAs. We want to serve fully-formed HTML for initial requests and, after the page loads, we want the browser-side application to take over and become an SPA. We want to avoid the above issues and enjoy all of the benefits of SPAs without paying the costs traditionally incurred by them.</p><p>Isomorphic is a term used to describe applications where the frontend and backend code are written in the same language and share a significant amount of logic, which facilitates features like this. Isomorphism has primarily been achieved by using JS (or a language like CoffeeScript that is little more than syntactic sugar for JS) on the server. In fact, I&rsquo;ve only seen the term &ldquo;Isomorphic&rdquo; used when immediately preceding &ldquo;JavaScript,&rdquo; but that doesn&rsquo;t have to be the case.</p><h3>A Better Language</h3><p>ClojureScript tools have changed dramatically in the past year.</p>
<ul>
<li><a href="https://github.com/facebook/react">React</a>, an excellent JS library for rendering, was released in May 2013. React supports multiple render targets; it can render to a DOM element or to an HTML string.</li>
<li><a href="https://github.com/swannodette/om">Om</a>, a ClojureScript wrapper for React that provides some important performance and architectural advantages, was released in January 2014.</li>
<li>JDK 8, which ships with a high-performance JavaScript engine called Nashorn that is compatible with React, was released in March 2014.</li>
<li><a href="https://github.com/clojure/core.async/">core.async</a>, a Clojure[Script] library that provides a great concurrency model, was released in June 2013.</li>
<li><a href="https://github.com/ptaoussanis/sente/">Sente</a>, a Clojure[Script] library for bidirectional asynchronous communication over HTTP and Web Sockets via core.async&rsquo;s channel interface, was released in February 2014.</li>
</ul><p>Though the toolset is not yet complete (which I will discuss further in Part 2), these libraries go a long way toward enabling isomorphism where it was previously infeasible.</p><p>Instead of running JS across the entire stack, we could run server-side Clojure, browser-side ClojureScript, render fully-formed HTML using Nashorn with Om/React, and share client and server code since Clojure and ClojureScript have nearly identical syntax and semantics.</p><h3>Is Clojure[Script] Ready?</h3><p>I wrote <a href="https://github.com/DomKM/omelette">Omelette</a>, an example application, to experiment with isomorphic Clojure[Script] patterns. It&rsquo;s a basic word-finding application. Given a string and desired position/s, it returns a list of words where the string is in the desired position. For example, searching for words that start with &ldquo;om&rdquo; would return a list that includes &ldquo;omelette.&rdquo;</p><p>The goal was to make an isomorphic SPA where all routes are renderable by the server without a significant amount of extra work, code duplication, or <code>(if server? ...)</code> conditionals. Additionally, the client-side code should be able to take over transparently and quickly; no white flash and no additional requests.</p><h3>Abstractions</h3><p>The code needed to work in three dissimilar environments: Clojure in the JVM, ClojureScript in Nashorn in the JVM, and ClojureScript in the browser. Sharing code requires abstractions.</p><h4>State Management</h4><p>The state of the application needs to be able to be usable in every environment. This one is easy since Clojure and ClojureScript have nearly identical syntax and semantics and can serialize to and deserialize from <a href="https://github.com/edn-format/edn">EDN</a>.</p><p>Omelette stores application state as a 2-tuple where the elements are a namespaced page keyword and a map of page data. For example, an application state of <code>[:omelette.page/search {:query &quot;bloop&quot; :options #{:prefix}}]</code> represents the &ldquo;Search&rdquo; page with a query input value of <code>&quot;bloop&quot;</code> and the <code>:prefix</code> option checked, while <code>[:omelette.page/about {:markdown &quot;# About ...&quot;}]</code> represents the &ldquo;About&rdquo; page with Markdown content.</p><h4>Rendering</h4><p>The application needs to be able to render to a DOM element and to an HTML string on the client-side and server-side respectively. Also, the browser-side application needs to be able to transition from static, server-rendered HTML to dynamic DOM rendering when it initializes in a browser.</p><p>Omelette uses Om/React for rendering. To serve HTML, Omelette server-side code uses an application state 2-tuple to render the view to a string within Nashorn, which returns a normal instance of <code>java.lang.String</code>. The HTML is embedded in a <code>div</code> in the document layout. The state is also serialized as EDN and embedded in the layout so that, when Omelette initializes in a browser, it doesn&rsquo;t have to make an additional request to fetch the initial data.</p><h4>Data Retrieval and Persistence</h4><p>Retrieving and persisting data needs to be easy to do for both initial page requests and running browser-side applications.</p><p>Omelette uses Sente for communication and reuses Sente&rsquo;s handler function for server-side rendering. Using the same handler makes it very easy to share this functionality.</p><h4>Routing</h4><p>Routing needs to work without requiring access to environment-specific things like the browser&rsquo;s <code>window</code> object or the server&rsquo;s incoming HTTP request. However, routes should be <em>able</em> to make use of environment-specific things, particularly on the server for authentication and authorization.</p><p>Omelette&rsquo;s search page is rendered at <code>&quot;/&quot;</code>, <code>&quot;/search&quot;</code>, and <code>&quot;/search/:options/:query&quot;</code> where <code>:options</code> is the desired position/s and <code>:query</code> is the target string. For example, <code>&quot;/search/prefix/bloop&quot;</code> is the path to find words that start with <code>&quot;bloop&quot;</code>. The &ldquo;About&rdquo; page is rendered at <code>&quot;/about&quot;</code>.</p><p>Routing in Omelette is unlike any routing functionality that I have seen elsewhere, so we should probably discuss it here. It has two steps:</p>
<ol>
<li>A path (<code>&quot;/search/bloop/prefix&quot;</code>) is transformed into an application state 2-tuple (<code>[:omelette.page/search {:query &quot;bloop&quot; :options #{:prefix}}]</code>).</li>
<li>An application state 2-tuple (<code>[:omelette.page/search {:query &quot;bloop&quot; :options #{:prefix}}]</code>) is passed through a handler function that pattern matches the state using <a href="https://github.com/clojure/core.match">core.match</a> and returns or responds with a modified state (<code>[:omelette.page/search {:query &quot;bloop&quot; :options #{:prefix} :results (&quot;bloop&quot; &quot;blooper&quot; &quot;blooping&quot;)}]</code>)</li>
</ol><p>All routes and application states are bidirectional. For example, the path <code>&quot;/search/bloop/prefix&quot;</code> can be derived from the application state returned from either of the above steps.</p><p>Additionally, though this is not strictly routing, document titles can be derived from application states. This is used for setting and updating the document title on the server and browser respectively.</p><p>Routing in Omelette is entirely ad hoc. In other words, routes are not defined using any sort of abstraction, but are manually converted to and from application state 2-tuples.</p><p>Routing is not a solved problem. There are no major Clojure[Script] routing libraries.</p><h3>Step by Step</h3>
<ol>
<li>A request is made to <code>&quot;/search/prefix/bloop&quot;</code>.</li>
<li>The request is converted to application state 2-tuple: <code>[:omelette.page/search {:query &quot;bloop&quot; :options #{:prefix}}]</code>.</li>
<li>The state gets passed through a handler function that returns a complete state: <code>[:omelette.page/search {:query &quot;bloop&quot; :options #{:prefix} :results (&quot;bloop&quot; &quot;blooper&quot; &quot;blooping&quot;)}]</code>.</li>
<li>The complete state is serialized to EDN and passed to Om/React through Nashorn, which returns an HTML string for that state.</li>
<li>The Om/React HTML string and application state EDN are inserted into the <code>body</code> of an HTML layout to form a complete document.</li>
<li>A response is sent with the document and a status that is determined by the page keyword; 404 if <code>:omelette.page/not-found</code>, 200 otherwise.</li>
<li>The Om/React application loads, uses the embedded EDN as the initial application state, and then mounts into the embedded HTML.</li>
<li>The ClojureScript router listens for navigation events and application state changes.</li>
<li>When the ClojureScript router detects a change, it updates <code>window.history</code> and sends the new application state (either the authoritative state or a state derived from the navigation event) to the server via Sente.</li>
<li>Sente passes the new state to the Clojure handler function. Since this time it is not an initial request, the router responds via Sente with an updated state.</li>
<li>Sente passes the new new state to the ClojureScript handler function which then updates the application state.</li>
<li>GOTO 9</li>
</ol><h3>Wrapping Up</h3><p>The full code for Omelette: <a href="https://github.com/DomKM/omelette">github.com/DomKM/omelette</a></p><p>Take a look at <a href="https://github.com/DomKM/omelette/blob/master/src%2Fomelette%2Frender.clj"><code>omelette.render</code> to see how Nashorn is used</a> and <a href="https://github.com/DomKM/omelette/blob/master/src%2Fomelette%2Fview.cljs"><code>omelette.view</code> to read through the Om code for rendering</a>. The bulk of Omelette&rsquo;s code is in <a href="https://github.com/DomKM/omelette/blob/master/src%2Fomelette%2Froute.cljx"><code>omelette.route</code></a> This uses <a href="https://github.com/lynaghk/cljx">cljx</a>, a tool that compiles .cljx files to both .clj and .cljs files. Forms prepended with <code>#+clj</code> and <code>#+cljs</code> will only be output to .clj and .cljs files respectively. This makes it easy to target both Clojure and ClojureScript with the same codebase. <code>omelette.route</code> provides routing helper functions, a ClojureScript router component using Om, and a Clojure router component using the descriptively but generically named <a href="https://github.com/stuartsierra/component">Component</a>.</p><p>Part 2 will discuss problems with the above approach to isomorphic Clojure[Script] and new libraries/patterns to alleviate these problems. Spoiler: It will be feasible to do server-side rendering without using Nashorn or any JS engine in the not-too-distant future.</p><p><em>Thanks to <a href="http://nelsonmorris.net/">Nelson Morris</a> and <a href="http://aphyr.com/">Kyle Kingsbury</a> for reviewing drafts of Omelette.</em></p></div><div id="disqus_thread"></div><script type="text/javascript">var disqus_shortname = 'paren';var disqus_title = 'Isomorphic Clojure[Script]: Part 1';var disqus_identifier = '/posts/isomorphic-clojure-part-1';var disqus_url = 'https://www.paren.com/posts/isomorphic-clojure-part-1';</script></article></div><footer><div class="footer-wrapper"><div class="made-with">Made with <span class="icon ion-pizza"></span> in NYC</div><div class="social-links"><ul><li><a href="https://twitter.com/paren_com" target="_blank"><span class="icon ion-social-twitter"></span></a></li><li><a href="https://github.com/paren-com" target="_blank"><span class="icon ion-social-github"></span></a></li><li><a href="../posts.atom" target="_blank"><span class="icon ion-social-rss"></span></a></li></ul></div><div class="copyright">Copyright © Paren</div></div></footer><script src="../bundles/63212946cc81/main.js" type="text/javascript"></script><script src="../bundles/8647f1865ec6/social.js" type="text/javascript"></script></body>
<!-- Mirrored from localhost:8080/posts/isomorphic-clojure-part-1 by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2023 22:58:09 GMT -->
</html>