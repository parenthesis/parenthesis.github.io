<!DOCTYPE html><html lang="en">
<!-- Mirrored from localhost:8080/posts/isomorphic-clojure-part-2-portable-code by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2023 22:58:09 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8" /><script src="../cdn-cgi/apps/head/8eW9U_40SfsrDtemBGnQeBr-CA0.js"></script><link href="http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,400italic,700,700italic|Ubuntu:300,300italic,400,400italic,700,700italic|Open+Sans:300,300italic,400,400italic,700,700italic" rel="stylesheet" type="text/css" /><link href="../bundles/25f08f0a7b5e/main.css" rel="stylesheet" type="text/css" /><title>Isomorphic Clojure[Script]: Part 2 (Portable Code) | (paren)</title><meta content="Portable code sharing for isomorphic Clojure[Script] applications." name="description" /><link href="https://www.paren.com/posts/isomorphic-clojure-part-2-portable-code" rel="canonical" /><meta content="width=device-width, initial-scale=1" name="viewport" /><link href="../assets/images/c369d834ca33/favicon-180.png" rel="apple-touch-icon" /><meta content="#FFFFFF" name="msapplication-TileColor" /><meta content="/assets/images/c369d834ca33/favicon-180.png" name="msapplication-TileImage" /><meta content="Isomorphic Clojure[Script]: Part 2 (Portable Code)" property="og:title" /><meta content="https://www.paren.com/posts/isomorphic-clojure-part-2-portable-code" property="og:url" /><meta content="Portable code sharing for isomorphic Clojure[Script] applications." property="description" /><meta content="en_US" property="og:locale" /><meta content="(paren)" property="og:site_name" /><meta content="article" property="og:type" /><meta content="2015-02-20T00:00:00.000Z" property="article:published_time" /><meta property="article:modified_time" /><meta content="https://www.facebook.com/DomKM" property="article:author" /><meta content="isomorphic" property="article:tag" /><meta content="clojure" property="article:tag" /><meta content="reader-conditionals" property="article:tag" /><meta content="feature-expressions" property="article:tag" /><meta content="clojurescript" property="article:tag" /><meta content="cljx" property="article:tag" /><meta content="summary" name="twitter:card" /><meta content="@paren_com" name="twitter:site" /><meta content="Isomorphic Clojure[Script]: Part 2 (Portable Code)" name="twitter:title" /><meta content="Portable code sharing for isomorphic Clojure[Script] applications." name="twitter:description" /><meta content="@DomKM" name="twitter:creator" /><link href="../sitemap.xml" rel="sitemap" title="Sitemap" type="application/xml" /><link href="../posts.atom" title="(blog)" type="application/atom+xml" /></head><body><header class="navigation"><div class="navigation-wrapper"><a class="logo" href="../index.html" style="margin-top:5px;margin-left:5px;"><img height="35" src="../assets/images/ca89ec253a40/paren-logo.png" width="126" /></a><label class="icon ion-navicon" id="hamburger-button"></label><ul class="navigation-menu"><a href="../index.html#testimonials">testimonials</a><a href="../index.html#videos">videos</a><a href="../index.html#process">process</a><a href="../index.html#team">team</a><a href="../index.html#contact">contact</a><a href="../posts.html">blog</a></ul></div></header><div id="main"><article id="post"><h1>Isomorphic Clojure[Script]</h1><h2>Part 2 (Portable Code)</h2><div class="post-data"><span class="post-author"><a href="https://twitter.com/DomKM" target="_blank">Dom Kiva-Meyer</a></span><time class="published" datetime="2015-02-20T00:00:00.000Z">February 20, 2015</time></div><ul class="post-tags"><li><a href="../postse7a5.html?tag=cljx">cljx</a></li><li><a href="../posts3c57.html?tag=clojure">clojure</a></li><li><a href="../postsc8a0.html?tag=clojurescript">clojurescript</a></li><li><a href="../posts2239.html?tag=feature-expressions">feature-expressions</a></li><li><a href="../posts0af7.html?tag=isomorphic">isomorphic</a></li><li><a href="../postsea6b.html?tag=reader-conditionals">reader-conditionals</a></li></ul><ul class="share-buttons"><li class="share-button"><a class="twitter-share-button" data-related="paren_com" data-text="Isomorphic Clojure[Script]: Part 2 (Portable Code)" data-url="https://www.paren.com/posts/isomorphic-clojure-part-2-portable-code" data-via="paren_com"></a></li><li class="share-button"><a class="fb-share-button" data-href="https://www.paren.com/posts/isomorphic-clojure-part-2-portable-code" data-layout="button_count"></a></li><li class="share-button"><a class="g-plusone" data-annotation="bubble" data-href="https://www.paren.com/posts/isomorphic-clojure-part-2-portable-code" data-size="medium"></a></li><li class="share-button"><a><script data-counter="right" data-showzero="true" data-url="https://www.paren.com/posts/isomorphic-clojure-part-2-portable-code" type="IN/Share"></script></a></li></ul><div class="post-body"><p>The most fundamental abstraction necessary for building isomorphic applications is code portability. We need to be able to write once and run in the server <em>and</em> browser. In a perfect world, we would write a language with identical syntax, semantics, and platform features. But that&rsquo;s unrealistic, so let&rsquo;s aim for similar syntax and semantics as well as an easy way to specify platform-specific units of code.</p><p>Our goal is for isomorphic Clojure[Script] applications to be more performant and easier to develop than their JavaScript counterparts. Outperforming JavaScript applications is easy; even V8 can&rsquo;t touch the JVM when it comes to runtime performance and React with persistent data structures blows everything else away. But making isomorphic Clojure[Script] applications easier to develop than JavaScript ones is no small task.</p><p>While JavaScript on the server and in the browser are not identical in features, they are identical in syntax and semantics when they share features, which is not something that can be said of Clojure and ClojureScript. One option would be to throw Clojure out and only use ClojureScript by running it in Node on the backend. This is a completely valid option, but sacrifices JVM performance and the plethora of excellent Clojure and Java libraries that are available.</p><p>Let&rsquo;s define the terms: An isomorphic Clojure[Script] application has a Clojure (JVM) backend and a ClojureScript (JavaScript) frontend where both sides of the application are capable of user-visible functionality like routing and rendering. This is the definition that I had in mind when writing <a href="https://github.com/DomKM/omelette">Omelette</a>. This architecture comes with more challenges than that of isomorphic JavaScript or isomorphic ClojureScript but the potential benefits make it worth pursuing. This post will focus on that of code portability. We want to write code that is portable; it will run in Clojure and ClojureScript and produce identical (or, in some cases, similar) results.</p><h2>Sharing Portable Code</h2><p>We need a way to share portable code so that we only have to write it once.</p><h3>Just Copy It</h3><p>The most obvious approach is to maintain multiple files per namespace; one file for each platform. Just copy the code from &ldquo;namespace.clj&rdquo; to &ldquo;namespace.cljs&rdquo; and modify the platform-specific parts.</p><p>But that&rsquo;s just&hellip;gross! Let&rsquo;s never speak of this again.</p><h3>Use <a href="https://github.com/emezeske/lein-cljsbuild/blob/8397716620e1686c9b1da27a00d8cbd30732d9c6/README.md">lein-cljsbuild crossovers</a></h3><p>This tool copies &ldquo;.clj&rdquo; files to &ldquo;.cljs&rdquo; files. It&rsquo;s better than the prior approach which shall not be named. However, its macro sharing functionality is clumsy and it totally ignores platform differences. For example, crossovers won&rsquo;t help unify <code>(Float/parseFloat &quot;3.14&quot;)</code> in Clojure with <code>(js/parseFloat &quot;3.14&quot;)</code> in ClojureScript.</p><p>Crossovers is now deprecated in favor of <a href="https://github.com/lynaghk/cljx">cljx</a>.</p><h3>cljx</h3><p>This is what is used in Omelette. Given &ldquo;namespace.cljx&rdquo;, cljx outputs &ldquo;namespace.clj&rdquo; and &ldquo;namespace.cljs&rdquo; files. Forms prepended with <code>#+clj</code> and <code>#+cljs</code> are only output to &ldquo;.clj&rdquo; and &ldquo;.cljs&rdquo; files respectively. As with lein-cljsbuild crossovers, cljx is a source-to-source compiler. Unlike lein-cljsbuild crossovers, cljx is more granular &ndash; compiling by form instead of file. This is the best solution that is currently available.</p><h3>Reader Conditionals</h3><p>Reader conditionals are a proposed feature in Clojure 1.7. You can read more about the design decisions and discussion on <a href="http://dev.clojure.org/display/design/Reader+Conditionals">dev.clojure.org</a>.</p><p>The current proposal satisfies the use case for cljx but differs in syntax and functionality. Unlike cljx, reader conditionals do not output new files; they extend the reader, allowing it to selectively read forms based on the current platform&rsquo;s features.</p><p>Reader conditionals introduce two new literal forms: <code>#?</code> (<code>read-cond</code>) and <code>#<a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="b887f8">[email&#160;protected]</a></code> (<code>read-cond-splicing</code>). The former reads a single expression and the latter reads a list and splices it into the parent form. Here&rsquo;s an example:</p>
<pre><code class="clojure">(ns my.namespace
  (:require [foo.bar #<a href="../cdn-cgi/l/email-protection.html" class="__cf_email__" data-cfemail="794639">[email&#160;protected]</a>(:cljs [:include-macros true])]
            [#?(:clj clojure.core.async :cljs cljs.core.async) :as csp])
  #?(:cljs (:require-macros [cljs.core.async.macros :as csp])))
</code></pre><h2>Challenges</h2><p>The fact that we can target the JVM and JavaScript from a single codebase is remarkable but is not without its challenges.</p><h3><code>(set/intersection Clojure ClojureScript)</code></h3><p>ClojureScript is not a subset of Clojure. It contains functionality that Clojure lacks. Portable code must target the intersection of Clojure and ClojureScript. That means no <code>extend</code> from Clojure or <code>specify</code> (an incredibly useful but underutilized function) from ClojureScript.</p><h3>Macros</h3><p>ClojureScript lacks native macros but is able to make use of Clojure macros. This is undoubtedly useful but is also lacking in several ways.</p>
<ul>
<li>Since ClojureScript lacks macros but can use Clojure macros, any platform-specific macro functionality will need to be implemented using conditionals and the contents of <code>&amp;env</code>. (Within a macro, <code>(:ns &amp;env)</code> is only truthy when expanding ClojureScript code.)</li>
<li>Macros are Clojure&rsquo;s only facility for doing work before runtime and are incredibly useful for optimizing performance without sacrificing syntax. The ability to do this in ClojureScript is significantly diminished because macros in ClojureScript (which are Clojure macros) cannot call ClojureScript functions.</li>
<li>Since ClojureScript macros are really Clojure macros, symbols are resolved in Clojure. For example, <code>map</code> would resolve to <code>clojure.core/map</code> instead of <code>cljs.core/map</code>. The only way around this faulty resolution is to quote and then unquote the symbol, like <code>~&#39;map</code>.</li>
</ul><h3>Core Implementation</h3><p>Clojure is primarily implemented with Java classes and interfaces in <code>clojure.lang.*</code>. ClojureScript is primarily implemented with types and protocols in <code>cljs.core/*</code>. This makes it cumbersome to extend core functionality.</p><p>For example, let&rsquo;s say we have a protocol that we want to extend to maps:</p>
<pre><code class="clojure">(defprotocol KeywordKeys
  (keyword-keys [this] &quot;Returns a seq of keys that are also keywords.&quot;))
</code></pre><p>In Clojure, we can extend it to the <code>IPersistentMap</code> interface:</p>
<pre><code class="clojure">(extend-protocol KeywordKeys
  clojure.lang.IPersistentMap
  (keyword-keys [this] (filter keyword? (keys this))))
</code></pre><p>In ClojureScript, we can only extend to concrete types because ClojureScript lacks interfaces and protocols cannot be extended to other protocols:</p>
<pre><code class="clojure">(extend-protocol KeywordKeys
  PersistentArrayMap
  (keyword-keys [this] (filter keyword? (keys this)))
  PersistentHashMap
  (keyword-keys [this] (filter keyword? (keys this))))
</code></pre><h3>Namespaces</h3><p>ClojureScript namespace declarations significantly differ from Clojure namespace declarations.</p>
<ul>
<li>ClojureScript has all sorts of extras for dealing with macros like <code>:require-macros</code> and <code>:include-macros</code>. The Clojure <code>ns</code> macro does not know how to deal with these extensions.</li>
<li>ClojureScript intentionally lacks <code>:use</code> and <code>:refer :all</code>. The ClojureScript <code>ns</code> macro does not know how to deal with these features.</li>
<li>Due to implementation differences, Clojure types are brought into a namespace with <code>:import</code> but ClojureScript types are brought into a namespace with <code>:require</code> and <code>:refer</code>.</li>
<li>ClojureScript namespaces are inconsistently named (<code>cljs.core</code> vs. <code>clojure.core</code>).</li>
<li>ClojureScript lacks some of Clojure&rsquo;s namespaces like <code>clojure.edn</code> and Clojure lacks some of ClojureScript&rsquo;s namespaces like <code>cljs.reader</code>.</li>
<li>Unlike other parts of ClojureScript which can be made to be more similar to Clojure via macros, namespaces are completely closed to user extension because ClojureScript lacks <code>require</code>.</li>
</ul><p>All of these issues combine to make namespaces declarations the most clumsy and redundant part of portable code.</p><h3>Host Interop</h3><p>Clojure&rsquo;s standard library lacks common functionality like <code>parseInt</code>. This is fine when running <em>only</em> on the JVM but causes pain when writing portable code due to Java and JavaScript inconsistencies. Since <code>java.lang.*</code> is imported into <code>clojure.core</code> but global JavaScript properties are accessible as <code>js/*</code>, even interop where Java and JavaScript are consistent require Clojure and ClojureScript forms that are inconsistent.</p><p>Additionally, even though Java and JavaScript ostensibly share some core types, they are often referenced differently in ClojureScript than in Clojure. For example, you <code>extend-protocol</code> to <code>String</code> in Clojure but <code>string</code> in ClojureScript. Similar pain occurs around exception handling and type hinting, since those parts of Clojure and ClojureScript are, at most, a paper-thin wrapper over their host platforms.</p><h3>Concurrency</h3><p>Clojure&rsquo;s concurrency primitives were designed with the JVM in mind and therefore require blocking. Since JavaScript is non-blocking, ClojureScript lacks Clojure&rsquo;s <code>future</code>, <code>promise</code>, <code>agent</code>, and <code>ref</code> concurrency primitives because they can block on <code>deref</code>. Without using any external libraries, writing portable concurrent code is tough.</p><h2>Positives</h2><h3><code>core.async</code></h3><p>Move &ldquo;Concurrency&rdquo; over to the positives because <code>core.async</code> rocks! It is tremendously helpful because it lets us write roughly the same asynchronous code in Clojure or ClojureScript despite ClojureScript neither having threads or being able to block. This is huge!</p><p>The community has been justifiable excited about <code>core.async</code>. While it is great in Clojure or ClojureScript, it really shines when writing portable code.</p><h3>It works!</h3><p>I can still barely believe that I am able to write virtually the same syntax and utilize Clojure&rsquo;s incredible features while enjoying JavaScript&rsquo;s incredible reach. Run everywhere JavaScript runs but write Clojure instead of JavaScript? Yes, please!</p></div><div id="disqus_thread"></div><script data-cfasync="false" src="../cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script type="text/javascript">var disqus_shortname = 'paren';var disqus_title = 'Isomorphic Clojure[Script]: Part 2 (Portable Code)';var disqus_identifier = '/posts/isomorphic-clojure-part-2-portable-code';var disqus_url = 'https://www.paren.com/posts/isomorphic-clojure-part-2-portable-code';</script></article></div><footer><div class="footer-wrapper"><div class="made-with">Made with <span class="icon ion-pizza"></span> in NYC</div><div class="social-links"><ul><li><a href="https://twitter.com/paren_com" target="_blank"><span class="icon ion-social-twitter"></span></a></li><li><a href="https://github.com/paren-com" target="_blank"><span class="icon ion-social-github"></span></a></li><li><a href="../posts.atom" target="_blank"><span class="icon ion-social-rss"></span></a></li></ul></div><div class="copyright">Copyright © Paren</div></div></footer><script src="../bundles/63212946cc81/main.js" type="text/javascript"></script><script src="../bundles/8647f1865ec6/social.js" type="text/javascript"></script></body>
<!-- Mirrored from localhost:8080/posts/isomorphic-clojure-part-2-portable-code by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 28 Jul 2023 22:58:09 GMT -->
</html>